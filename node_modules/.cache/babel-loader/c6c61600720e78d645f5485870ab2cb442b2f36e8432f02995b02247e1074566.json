{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { onMounted, onUpdated } from 'vue';\nimport { useEventListener } from '@vueuse/core';\nimport { useNamespace } from '../../../../hooks/use-namespace/index.mjs';\nimport { getEventCode } from '../../../../utils/dom/event.mjs';\nimport { EVENT_CODE } from '../../../../constants/aria.mjs';\nfunction useKeydown({\n  el$\n}, store) {\n  const ns = useNamespace(\"tree\");\n  onMounted(() => {\n    initTabIndex();\n  });\n  onUpdated(() => {\n    const checkboxItems = Array.from(el$.value.querySelectorAll(\"input[type=checkbox]\"));\n    checkboxItems.forEach(checkbox => {\n      checkbox.setAttribute(\"tabindex\", \"-1\");\n    });\n  });\n  function canNodeFocus(treeItems, nextIndex) {\n    var _a, _b;\n    const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key);\n    return currentNode.canFocus && currentNode.visible && (((_a = currentNode.parent) == null ? void 0 : _a.expanded) || ((_b = currentNode.parent) == null ? void 0 : _b.level) === 0);\n  }\n  const handleKeydown = ev => {\n    const currentItem = ev.target;\n    if (!currentItem.className.includes(ns.b(\"node\"))) return;\n    const code = getEventCode(ev);\n    const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    const currentIndex = treeItems.indexOf(currentItem);\n    let nextIndex;\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault();\n      if (code === EVENT_CODE.up) {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex !== 0 ? currentIndex - 1 : treeItems.length - 1;\n        const startIndex = nextIndex;\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break;\n          }\n          nextIndex--;\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n          if (nextIndex < 0) {\n            nextIndex = treeItems.length - 1;\n          }\n        }\n      } else {\n        nextIndex = currentIndex === -1 ? 0 : currentIndex < treeItems.length - 1 ? currentIndex + 1 : 0;\n        const startIndex = nextIndex;\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break;\n          }\n          nextIndex++;\n          if (nextIndex === startIndex) {\n            nextIndex = -1;\n            break;\n          }\n          if (nextIndex >= treeItems.length) {\n            nextIndex = 0;\n          }\n        }\n      }\n      nextIndex !== -1 && treeItems[nextIndex].focus();\n    }\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault();\n      currentItem.click();\n    }\n    const hasInput = currentItem.querySelector('[type=\"checkbox\"]');\n    if ([EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(code) && hasInput) {\n      ev.preventDefault();\n      hasInput.click();\n    }\n  };\n  useEventListener(el$, \"keydown\", handleKeydown);\n  const initTabIndex = () => {\n    var _a;\n    if (!el$.value) return;\n    const treeItems = Array.from(el$.value.querySelectorAll(`.${ns.is(\"focusable\")}[role=treeitem]`));\n    const checkboxItems = Array.from(el$.value.querySelectorAll(\"input[type=checkbox]\"));\n    checkboxItems.forEach(checkbox => {\n      checkbox.setAttribute(\"tabindex\", \"-1\");\n    });\n    const checkedItem = el$.value.querySelectorAll(`.${ns.is(\"checked\")}[role=treeitem]`);\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute(\"tabindex\", \"0\");\n      return;\n    }\n    (_a = treeItems[0]) == null ? void 0 : _a.setAttribute(\"tabindex\", \"0\");\n  };\n}\nexport { useKeydown };","map":{"version":3,"names":["useKeydown","el$","store","ns","useNamespace","onMounted","initTabIndex","onUpdated","checkboxItems","Array","from","value","querySelectorAll","forEach","checkbox","setAttribute","canNodeFocus","treeItems","nextIndex","_a","_b","currentNode","getNode","dataset","key","canFocus","visible","parent","expanded","level","handleKeydown","ev","currentItem","target","className","includes","b","code","getEventCode","is","currentIndex","indexOf","EVENT_CODE","up","down","preventDefault","length","startIndex","focus","left","right","click","hasInput","querySelector","enter","numpadEnter","space","useEventListener","checkedItem"],"sources":["../../../../../../../packages/components/tree/src/model/useKeydown.ts"],"sourcesContent":["import { onMounted, onUpdated } from 'vue'\nimport { useEventListener } from '@vueuse/core'\nimport { EVENT_CODE } from '@element-plus/constants'\nimport { useNamespace } from '@element-plus/hooks'\nimport { getEventCode } from '@element-plus/utils'\n\nimport type TreeStore from './tree-store'\nimport type { Ref } from 'vue'\nimport type { Nullable } from '@element-plus/utils'\n\ninterface UseKeydownOption {\n  el$: Ref<HTMLElement | null>\n}\nexport function useKeydown({ el$ }: UseKeydownOption, store: Ref<TreeStore>) {\n  const ns = useNamespace('tree')\n\n  onMounted(() => {\n    initTabIndex()\n  })\n\n  onUpdated(() => {\n    const checkboxItems = Array.from(\n      el$.value!.querySelectorAll('input[type=checkbox]')\n    )\n    checkboxItems.forEach((checkbox) => {\n      checkbox.setAttribute('tabindex', '-1')\n    })\n  })\n\n  function canNodeFocus(treeItems: HTMLElement[], nextIndex: number): boolean {\n    const currentNode = store.value.getNode(treeItems[nextIndex].dataset.key!)\n    return (\n      currentNode.canFocus &&\n      currentNode.visible &&\n      (currentNode.parent?.expanded || currentNode.parent?.level === 0)\n    )\n  }\n\n  const handleKeydown = (ev: KeyboardEvent): void => {\n    const currentItem = ev.target as HTMLDivElement\n    if (!currentItem.className.includes(ns.b('node'))) return\n    const code = getEventCode(ev)\n    const treeItems: HTMLElement[] = Array.from(\n      el$.value!.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    const currentIndex = treeItems.indexOf(currentItem)\n    let nextIndex\n    if ([EVENT_CODE.up, EVENT_CODE.down].includes(code)) {\n      ev.preventDefault()\n      if (code === EVENT_CODE.up) {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex !== 0\n            ? currentIndex - 1\n            : treeItems.length - 1\n        const startIndex = nextIndex\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break\n          }\n\n          nextIndex--\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex < 0) {\n            nextIndex = treeItems.length - 1\n          }\n        }\n      } else {\n        nextIndex =\n          currentIndex === -1\n            ? 0\n            : currentIndex < treeItems.length - 1\n            ? currentIndex + 1\n            : 0\n        const startIndex = nextIndex\n        while (true) {\n          if (canNodeFocus(treeItems, nextIndex)) {\n            break\n          }\n\n          nextIndex++\n          if (nextIndex === startIndex) {\n            nextIndex = -1\n            break\n          }\n          if (nextIndex >= treeItems.length) {\n            nextIndex = 0\n          }\n        }\n      }\n      nextIndex !== -1 && treeItems[nextIndex].focus()\n    }\n    if ([EVENT_CODE.left, EVENT_CODE.right].includes(code)) {\n      ev.preventDefault()\n      currentItem.click()\n    }\n    const hasInput = currentItem.querySelector(\n      '[type=\"checkbox\"]'\n    ) as Nullable<HTMLInputElement>\n    if (\n      [EVENT_CODE.enter, EVENT_CODE.numpadEnter, EVENT_CODE.space].includes(\n        code\n      ) &&\n      hasInput\n    ) {\n      ev.preventDefault()\n      hasInput.click()\n    }\n  }\n\n  useEventListener(el$, 'keydown', handleKeydown)\n\n  const initTabIndex = (): void => {\n    if (!el$.value) return\n    const treeItems = Array.from(\n      el$.value.querySelectorAll(`.${ns.is('focusable')}[role=treeitem]`)\n    )\n    const checkboxItems = Array.from(\n      el$.value.querySelectorAll('input[type=checkbox]')\n    )\n    checkboxItems.forEach((checkbox) => {\n      checkbox.setAttribute('tabindex', '-1')\n    })\n    const checkedItem = el$.value.querySelectorAll(\n      `.${ns.is('checked')}[role=treeitem]`\n    )\n    if (checkedItem.length) {\n      checkedItem[0].setAttribute('tabindex', '0')\n      return\n    }\n    treeItems[0]?.setAttribute('tabindex', '0')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}